/*
https://programmers.co.kr/learn/courses/30/lessons/68645

삼각 달팽이
문제 설명

정수 n이 매개변수로 주어집니다. 다음 그림과 같이 밑변의 길이와 높이가 n인 삼각형에서 맨 위 꼭짓점부터 반시계 방향으로 달팽이 채우기를 진행한 후, 첫 행부터 마지막 행까지 모두 순서대로 합친 새로운 배열을 return 하도록 solution 함수를 완성해주세요.



제한사항

n은 1 이상 1,000 이하입니다.

입출력 예

n	result
4	[1,2,9,3,10,8,4,5,6,7]
5	[1,2,12,3,13,11,4,14,15,10,5,6,7,8,9]
6	[1,2,15,3,16,14,4,17,21,13,5,18,19,20,12,6,7,8,9,10,11]

*/

function solution(n) {
  let tri = new Array(n).fill(0);
  for (let i = 0; i < n; i++) tri[i] = new Array(i + 1).fill(0);
  let x = 0;
  let y = -1;
  let number = 1;

  for (let i = 0; i < n; i++) {
    for (let j = i; j < n; j++) {
      if (i % 3 === 0) y += 1;
      else if (i % 3 === 1) x += 1;
      else (y -= 1), (x -= 1);
      tri[y][x] = number;
      number += 1;
    }
  }
  return tri.flat();
}

/*
먼저 삼각형 형태의 배열 tri를 만들어 줬다.
그리고 좌표 x,y를 선언하고 (y는 첫 값을 넣어주기 위해서 -1로 지정) 처음은 삼각형의 위에서 밑으로 내려가면서 숫자가 들어가기 때문에 i% 3 이 0인 경우 y축이 커지고 두번째로 오른쪽으로 진행 되기 때문에 x축이 움직였으며 마지막으로 다시 초기 위치로 향하기 때문에 x축과 y축을 모두 1씩 빼주는 진행이 됐다. 두번째 반복문 j의 초기 값이 i인 이유는 숫자가 들어갈 때 선이 꺾일 때마다 선의 길이가 1씩 빠지기 때문이다.
그리고 마지막에 이중배열을 없애주는 flat()을 활용해서 리턴해주면 문제에서 원하는 답이 나온다.
*/

/********************************************************/

/*
https://programmers.co.kr/learn/courses/30/lessons/77885

2개 이하로 다른 비트
문제 설명

양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.

x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수
예를 들어,

f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

수	비트	다른 비트의 개수
2	000...0010	
3	000...0011	1
f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

수	비트	다른 비트의 개수
7	000...0111	
8	000...1000	4
9	000...1001	3
10	000...1010	3
11	000...1011	2
정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

제한사항

1 ≤ numbers의 길이 ≤ 100,000
0 ≤ numbers의 모든 수 ≤ 1015

입출력 예

numbers	result
[2,7]	[3,11]

*/

function solution(numbers) {
  var answer = [];

  for (let el of numbers) {
    let binary = el.toString(2);
    if (binary[binary.length - 1] === "0") answer.push(el + 1);
    else {
      let idx = binary.lastIndexOf("01");
      let num = binary.substring(0, idx) + "10" + binary.substring(idx + 2);
      answer.push(Number.parseInt(num, 2));
    }
  }
  return answer;
}

/*
number의 요소를 2진수로 바꿔준다. 그 뒤로 가장 마지막 수가 0 인 이진수는 number의 요소에 1을 더해줘서 값에 넣어준다.

그렇지 않을 경우 가장 마지막에 있는 문자열 "01"이 "10"으로 바뀌면 비트가 1~2개만 다른 수 중 number보다 큰 최소의 이진수 x가 나오게 되고 이진수 x를 10진수로 바꿔서 값에 넣어준 뒤 리턴하게 되면 정답이 나온다. 조건이 1~2개만 다른 비트인 숫자를 구하는 것인데 짝수의 경우 1의자리 이진수만 바꿔주면 되기에 1개만 다른 비트이고 홀 수의 경우 2개의 다른 비트를 가져야하고 이외에는 같아야하며 그중에서도 가장 작은 수를 구해야했기에 "01"을 "10"으로 바꿔주게 됐다.
*/
